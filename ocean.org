#+TITLE: ModelE Land Ice (LIME) Ocean Coupling
#+AUTHOR: Ken Mankoff
#+EMAIL: ken.mankoff@nasa.gov

#+OPTIONS:   H:4 num:4 toc:4 \n:nil ::t |:t ^:{} -:t f:t *:t <:t

#+PROPERTY: header-args :eval no-export :noweb yes :comments both
#+PROPERTY: header-args:bash+ :session (concat "*" (file-name-sans-extension (buffer-name)) "-shell*")
#+PROPERTY: header-args:bash+ :tangle-mode (identity #o744) :shebang #!/usr/bin/env bash
#+PROPERTY: header-args:jupyter-python+ :session LIME_ocean :kernel ds :dir .

* Table of contents                               :toc_4:noexport:
- [[#introduction][Introduction]]
- [[#summary][Summary]]
- [[#implementation][Implementation]]
  - [[#post-process-one-month-data-from-modele-to-more-generic-format][Post-process one month data from ModelE to more generic format]]
  - [[#set-up-modele-domain][Set up ModelE domain]]
  - [[#import][Import]]
    - [[#meta][Meta]]
    - [[#temperature--salinity][Temperature & salinity]]
  - [[#reproject][Reproject]]
    - [[#greenland][Greenland]]
    - [[#antarctica][Antarctica]]
  - [[#export-to-netcdf][Export to NetCDF]]
    - [[#display][Display]]
    - [[#merge-modele-output-with-lime-metadata][Merge ModelE output with LIME metadata]]
    - [[#select-appropriate-t--s-depth-for-each-cell][Select appropriate T & S depth for each cell]]
    - [[#notdone-select-appropriate-t--s-for-each-basin][NOTDONE Select appropriate T & S for each basin]]
    - [[#create-basin-ids][Create basin IDs]]
    - [[#reformat-to-meet-pism-requirements][Reformat to meet PISM requirements]]
  - [[#test-run-in-pism][Test run in PISM]]

* Introduction

Notes, code, and documentation on coupling the ModelE ocean with PISM.

Eventual goal is bi-directional coupling so that ModelE ocean (temperature, salinity) forces PISM, and PISM freshwater is returned to ModelE.

At the moment coupling is one-way: We drive PISM with ModelE, using monthly coupling.

* Summary

This summary may be out of date. See TOC, section headings, and code within for definitive code used to generate the products. Work plan is, roughly:

+ Select ModelE ocean cells bordering Antarctica and Greenland
  + Extract =pot_temp=, =salinity=, and other needed metadata
+ Reproject from ModelE grid to PISM grid
+ Select relevant depth of ocean properties
  + GZ draft, bathymetric routing to shelf break, etc.

+ WARN :: Use nearest neighbor sampling otherwise interpolation would occur, which might be OK for T or S, but unlikely to produce reasonable density which is ~f(T,S)~.
    
* Implementation

** Post-process one month data from ModelE to more generic format

#+BEGIN_SRC bash :exports both :results verbatim
RUNNAME=E1oM20_r01
MONTH=FEB
YEAR=2001

month_names=($(locale mon|tr '[:lower:]' '[:upper:]'| tr ';' '\n' |cut -c1-3))
month_num=$(echo ${month_names[@]} |tr ' ' '\n' | cat -n|grep ${MONTH} |tr -cd '[:digit:]')
printf -v month_num "%02d" $month_num # 0 padding

scaleacc ${CMRUNDIR}/${RUNNAME}/${MONTH}${YEAR}.acc${RUNNAME}.nc oijl
mv ${MONTH}${YEAR}.oijl${RUNNAME}.nc oijl.nc

scaleacc ${CMRUNDIR}/${RUNNAME}/${MONTH}${YEAR}.acc${RUNNAME}.nc aij
mv ${MONTH}${YEAR}.aij${RUNNAME}.nc aij.nc
#+END_SRC

** Set up ModelE domain

+ Note, 4x5 arrays have a smaller polar cell.
+ Easiest to set two domains
  + 4x5 +- 92 °
  + 2x2.5 +- 90 °

Resample to the +- 90 ° domain.

#+BEGIN_SRC bash :exports both :results verbatim
grass ./G_ModelE/PERMANENT
# g.region -ps n=90 s=-90 w=-180 e=180 nsres=1 ewres=1

g.mapset -c 4x5

# hack for ModelE polar cells
g.region -p n=92 s=-92 w=-180 e=180 nsres=4 ewres=5
g.region save=4x5_92

g.mapset -c 2x2p5
g.region -p n=90 s=-90 nsres=2 ewres=2.5
g.region save=2x2p5_90
#+END_SRC

** Import 
*** Meta
#+BEGIN_SRC bash :exports both :results verbatim
g.mapset 4x5
r.in.gdal -o input=NetCDF:aij.nc:landicefr output=landicefr
r.in.gdal -o input=NetCDF:aij.nc:landfr output=landfr
r.in.gdal -o input=NetCDF:aij.nc:ocnfr output=ocnfr

g.mapset 2x2p5
r.resample input=landicefr@4x5 output=landicefr
r.resample input=landfr@4x5 output=landfr
r.resample input=ocnfr@4x5 output=ocnfr
#+END_SRC

*** Temperature & salinity

#+BEGIN_SRC bash :exports both :results verbatim
nlevel=$(ncks -M -C -v zoc oijl.nc |grep "zoc = "|tr -cd '[:digit:]')
levels=($(seq -w ${nlevel}))

for lev in ${levels[@]}; do
  g.mapset 4x5
  r.in.gdal -o input=NetCDF:oijl.nc:salt output=salt_${lev} band=${lev}
  r.in.gdal -o input=NetCDF:oijl.nc:pot_temp output=temp_${lev} band=${lev}

  g.mapset 2x2p5
  r.resample input=salt_${lev}@4x5 output=salt_${lev}
  r.resample input=temp_${lev}@4x5 output=temp_${lev}
done
#+END_SRC

** Reproject
*** Greenland

The =r.grow.distance= flood-fills the values with nearest neighbor. This is because ModelE coast may not match PISM coast, but we will want to be able to access the T and S values nearest the coast.

#+BEGIN_SRC bash :exports both :results verbatim
grass ./G_GL/PERMANENT

nlevel=$(ncks -M -C -v zoc oijl.nc |grep "zoc = "|tr -cd '[:digit:]')
levels=($(seq -w ${nlevel}))

r.proj location=G_ModelE mapset=2x2p5 input=landicefr method=nearest 
r.proj location=G_ModelE mapset=2x2p5 input=landfr method=nearest
r.proj location=G_ModelE mapset=2x2p5 input=ocnfr method=nearest

# rasters=$(r.proj location=G_ModelE mapset=2x2p5  -l |grep -E '^temp_|^salt_')
# parallel --progress --bar "r.proj --q location=G_ModelE mapset=2x2p5 input={1} method=nearest" ::: ${rasters}
for var in salt temp; do
  for lev in ${levels[@]}; do
    r.proj location=G_ModelE mapset=2x2p5 input=${var}_${lev} output=${var}_${lev}_E method=nearest
    r.grow.distance input=${var}_${lev}_E value=${var}_${lev}
  done
done
exit
#+END_SRC

*** Antarctica
#+BEGIN_SRC bash :exports both :results verbatim
grass ./G_AQ/PERMANENT

nlevel=$(ncks -M -C -v zoc oijl.nc |grep "zoc = "|tr -cd '[:digit:]')
levels=($(seq -w ${nlevel}))

r.proj -n location=G_ModelE mapset=2x2p5 input=landicefr method=nearest 
r.proj -n location=G_ModelE mapset=2x2p5 input=landfr method=nearest
r.proj -n location=G_ModelE mapset=2x2p5 input=ocnfr method=nearest

for var in salt temp; do
  for lev in ${levels[@]}; do
    r.proj -n location=G_ModelE mapset=2x2p5 input=${var}_${lev} output=${var}_${lev}_E method=nearest
    r.grow.distance input=${var}_${lev}_E value=${var}_${lev}
  done
done
exit
#+END_SRC

** Export to NetCDF

#+BEGIN_SRC jupyter-python :exports both
import numpy as np
import xarray as xr

from grass_session import Session
from grass.script import core as gcore
import grass.script as gscript
# import grass.script.setup as gsetup
# import grass python libraries
from grass.pygrass.modules.shortcuts import general as g
from grass.pygrass.modules.shortcuts import raster as r
from grass.pygrass.modules.shortcuts import vector as v
from grass.pygrass.modules.shortcuts import temporal as t
from grass.script import array as garray

levels = xr.open_dataset('oijl.nc')['zoc'].values

for loc in ['GL','AQ']:
    ds = xr.Dataset()
    with Session(gisdb=".", location="G_"+loc, mapset="PERMANENT", create_opts=None):

        x = garray.array("x", null=np.nan)
        y = garray.array("y", null=np.nan)
        ds['z'] = levels
        ds['x'] = x[0,:]
        ds['y'] = y[:,0][::-1]

        for var in ['temp','salt']:
            for i,lev in enumerate(levels):
                ii = str(i+1).zfill(2)
                tmp = garray.array(f"{var}_{ii}", null=np.nan)
                ds[f"{var}_{ii}"] = (('y','x'),tmp)

        lnum = [str(n+1).zfill(2) for n in range(levels.size)]
        temp3d = xr.concat([ds[f"temp_{n}"] for n in lnum], dim='z')
        salt3d = xr.concat([ds[f"salt_{n}"] for n in lnum], dim='z')
        ds['temp'] = (('z','y','x'), temp3d.data)
        ds['salt'] = (('z','y','x'), salt3d.data)
        for n in lnum:
            ds = ds.drop([f"temp_{n}",f"salt_{n}"])

        ds.to_netcdf(f"E2P_{loc}.nc")
#+END_SRC

#+RESULTS:

*** Display

#+BEGIN_SRC jupyter-python :exports both :results file :file figs/E2P_AQ_salt.png
ds = xr.open_dataset("E2P_AQ.nc")
_ = ds['salt'].plot(col='z', col_wrap=4, robust=True)
#+END_SRC

#+RESULTS:
[[file:figs/E2P_AQ_salt.png]]


*** Merge ModelE output with LIME metadata

#+BEGIN_SRC jupyter-python :exports both
import numpy as np
import xarray as xr

aq_meta = xr.open_dataset("LIME_AQ.nc")
aq_me = xr.open_dataset("E2P_AQ.nc")
aq = xr.merge([aq_meta,aq_me])

gl_meta = xr.open_dataset("LIME_GL.nc")
gl_me = xr.open_dataset("E2P_GL.nc")
gl = xr.merge([gl_meta,gl_me])
#+END_SRC

#+RESULTS:

*** Select appropriate T & S depth for each cell

#+BEGIN_SRC jupyter-python :exports both

# # 800 m
# aq = aq.sel(z=800, method="nearest")
# gl = gl.sel(z=800, method="nearest")

# average of top 800 m
aq = aq.sel({'z':slice(0,800)}).mean(dim='z')
gl = gl.sel({'z':slice(0,800)}).mean(dim='z')
#+END_SRC

#+RESULTS:

*** NOTDONE Select appropriate T & S for each basin

#+BEGIN_SRC jupyter-python :exports both
# aq.groupby('shoreface_basins_100').mean()['salt'].values
#+END_SRC

#+RESULTS:

*** Create basin IDs

#+BEGIN_SRC jupyter-python :exports both
basins = aq['shoreface_basins_100'].values
for i,b in enumerate(np.unique(basins)):
    if np.isnan(b): basins[np.isnan(basins)] = 0
    basins[basins == b] = i+1
aq['basins'] = (('y','x'), basins)    

basins = gl['shoreface_basins_100'].values
for i,b in enumerate(np.unique(basins)):
    if np.isnan(b): basins[np.isnan(basins)] = 0
    basins[basins == b] = i+1
gl['basins'] = (('y','x'), basins)
#+END_SRC


*** Reformat to meet PISM requirements

#+BEGIN_SRC jupyter-python :exports both
aq = aq.rename({'temp':'theta_ocean',
                'salt':'salinity_ocean'})
aq['theta_ocean'].attrs['units'] = 'Celsius'
aq['salinity_ocean'].attrs['units'] = 'g/kg'
aq.to_netcdf('ocean_PICO_AQ.nc')

gl = gl.rename({'temp':'theta_ocean',
                'salt':'salinity_ocean'})
gl['theta_ocean'].attrs['units'] = 'Celsius'
gl['salinity_ocean'].attrs['units'] = 'g/kg'
gl.to_netcdf('ocean_PICO_GL.nc')
#+END_SRC

** Test run in PISM

#+BEGIN_SRC bash :exports both :results verbatim

cd ${LIME_ROOT}/runs/ocean.PICO
cp ${LIME_ROOT}/../docs/ocean_PICO_* .

mpiexec -n 4 \
	pismr \
	-i ../pism_Greenland_5km_v1.1.nc \
	-Mx 76 -My 141 -Mz 101 -Mbz 11 \
	-z_spacing equal \
	-Lz 4000 -Lbz 2000 \
	-skip -skip_max 10 \
	-grid.recompute_longitude_and_latitude false \
	-grid.registration corner \
	-surface given \
	-surface_given_file ../pism_Greenland_5km_v1.1.nc \
	-front_retreat_file ../pism_Greenland_5km_v1.1.nc \
	-sia_e 3.0 \
	-stress_balance ssa+sia \
	-topg_to_phi 15.0,40.0,-300.0,700.0 \
	-pseudo_plastic \
	-pseudo_plastic_q 0.5 \
	-till_effective_fraction_overburden 0.02 \
	-tauc_slippery_grounding_lines \
	-ts_file ts_g20km_10ka_hy.nc \
	-extra_file ex_g20km_10ka_hy.nc \
	-extra_vars diffusivity,temppabase,tempicethk_basal,bmelt,tillwat,velsurf_mag,mask,thk,topg,usurf,hardav,velbase_mag,tauc,tendency_of_ice_mass_due_to_discharge,basal_melt_rate_grounded,bmelt \
	-bootstrap \
	-ys 0 -ye 100 \
	-extra_times 0:10:1000 \
	-ts_times 0:yearly:1000 \
	-ocean pico\
	-ocean.pico.file ocean_PICO_GL.nc \
	-ocean.pico.periodic no \
	-frontal_melt.constant.melt_rate 100 \
	-o g20km_1ka_ocean_PICO.nc 
#+END_SRC

